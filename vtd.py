# -*- coding: utf-8 -*-
import requests
import time
import os
import uuid
import random
import hashlib
from datetime import datetime, timezone, timedelta
from urllib.parse import urlparse, parse_qs
from colorama import Fore, init, Style
import platform
import subprocess

init(autoreset=True)

# Danh s√°ch User-Agents ƒë∆∞·ª£c thay th·∫ø t·ª´ y√™u c·∫ßu c·ªßa b·∫°n
USER_AGENTS = [
    # Windows Chrome
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36",

    # Windows Firefox
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:113.0) Gecko/20100101 Firefox/113.0",
    "Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:116.0) Gecko/20100101 Firefox/116.0",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:117.0) Gecko/20100101 Firefox/117.0",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0",

    # Linux Chrome
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36",
    "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:119.0) Gecko/20100101 Firefox/119.0",
    "Mozilla/5.0 (X11; Fedora; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
    "Mozilla/5.0 (X11; Linux x86_64; rv:114.0) Gecko/20100101 Firefox/114.0",

    # Mac Safari
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5 Safari/605.1.15",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 13_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5 Safari/605.1.15",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Safari/605.1.15",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15",

    # iPhone Safari
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 15_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.6 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.6 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.7 Mobile/15E148 Safari/604.1",

    # iPad Safari
    "Mozilla/5.0 (iPad; CPU OS 16_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (iPad; CPU OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (iPad; CPU OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.6 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (iPad; CPU OS 17_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (iPad; CPU OS 13_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.5 Mobile/15E148 Safari/604.1",

    # Android Chrome
    "Mozilla/5.0 (Linux; Android 12; SM-G998B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 10; SM-A515F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 13; SM-S918B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 9; SM-G960F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36",

    # Android kh√°c
    "Mozilla/5.0 (Linux; Android 12; Xiaomi 12 Pro) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 11; Redmi Note 10 Pro) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 10; Vivo V20) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 13; OnePlus 11) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 12; Oppo Reno8) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36",

    # Edge
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.51",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Edg/115.0.1901.188",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.67",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Edg/115.0.1901.203",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1 EdgiOS/115.0.1901.183",
]

ascii_art = """
        
 ‚ñå ‚ñê¬∑    ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ    ¬∑‚ñÑ‚ñÑ‚ñÑ‚ñÑ  
‚ñ™‚ñà¬∑‚ñà‚ñå    ‚Ä¢‚ñà‚ñà      ‚ñà‚ñà‚ñ™ ‚ñà‚ñà 
‚ñê‚ñà‚ñê‚ñà‚Ä¢     ‚ñê‚ñà.‚ñ™    ‚ñê‚ñà¬∑ ‚ñê‚ñà‚ñå
 ‚ñà‚ñà‚ñà      ‚ñê‚ñà‚ñå¬∑    ‚ñà‚ñà. ‚ñà‚ñà 
. ‚ñÄ       ‚ñÄ‚ñÄ‚ñÄ     ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚Ä¢ 
   ùêÄùêÆùê≠ùê® ƒêùêöÃ£ÃÜùê≠ ùêÇùêÆÃõùê®ÃõÃ£ùêú ùêïùêìùêÉ
                                                                                   
                                             """

# m√†u
colors = [
    Fore.RED,
    Fore.YELLOW,
    Fore.GREEN,
    Fore.CYAN,
    Fore.BLUE,
    Fore.MAGENTA
]

# load ASCII 
def display_ascii_art():
    lines = ascii_art.strip().split('\n')
    for i in range(len(lines)):
        os.system('cls' if os.name == 'nt' else 'clear')
        current_lines = lines[:i + 1]
        for line_idx, line in enumerate(current_lines):
            colored_line = ''
            for j, char in enumerate(line):
                color_idx = (j + line_idx) % len(colors)
                colored_line += colors[color_idx] + char
            print(colored_line + Style.RESET_ALL)
        time.sleep(0.1)
    os.system('cls' if os.name == 'nt' else 'clear')
    for line in lines:
        colored_line = ''
        for j, char in enumerate(line):
            color_idx = j % len(colors)
            colored_line += colors[color_idx] + char
        print(colored_line + Style.RESET_ALL)
    print()

# B·∫£n ƒë·ªì t√™n ph√≤ng
room_names_map = {
    "1": "B·∫≠c Th·∫ßy T·∫•n C√¥ng",
    "2": "Quy·ªÅn S·∫Øt",
    "3": "Th·ª£ L·∫∑n S√¢u",
    "4": "C∆°n L·ªëc S√¢n C·ªè",
    "5": "Hi·ªáp Sƒ© Phi Nhanh",
    "6": "Vua Home Run",
}

SECRET = "MY_SECRET_SALT"
GLOBAL_KEY_MODE = None

def get_device_id(mode="mac"):
    try:
        android_id = os.popen("settings get secure android_id").read().strip()
        model = os.popen("getprop ro.product.model").read().strip()
        brand = os.popen("getprop ro.product.brand").read().strip()
        serial = os.popen("getprop ro.serialno").read().strip()

        if android_id and model and brand:
            raw = f"{android_id}-{brand}-{model}-{serial}"
        else:
            raise Exception("Not Android")
    except:
        if mode == "mac":
            raw = str(uuid.getnode())
        elif mode == "cpu":
            raw = f"{platform.processor()}-{platform.machine()}"
        elif mode == "disk":
            try:
                if platform.system() == "Windows":
                    disk_serial = subprocess.check_output(
                        "wmic diskdrive get SerialNumber", shell=True
                    ).decode(errors="ignore").split("\n")[1].strip()
                else:
                    disk_serial = subprocess.check_output(
                        "udevadm info --query=property --name=/dev/sda | grep ID_SERIAL",
                        shell=True
                    ).decode(errors="ignore").strip()
            except:
                disk_serial = "NOSERIAL"
            raw = disk_serial
        else:
            raw = f"{platform.node()}-{platform.system()}-{platform.release()}"

    device_id = "DEVICE-" + hashlib.md5(raw.encode()).hexdigest()[:25].upper()
    print(Fore.BLUE + "üìå Device ID:" + Fore.YELLOW + f" {device_id}")
    return device_id

def make_free_key(user_id):
    today = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    raw = today + SECRET + user_id
    return hashlib.md5(raw.encode()).hexdigest()[:10].upper()

def thoi_gian_con_lai_trong_ngay():
    now = datetime.utcnow() + timedelta(hours=7)
    tomorrow = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
    delta = tomorrow - now
    hours, remainder = divmod(delta.seconds, 3600)
    minutes = remainder // 60
    return hours, minutes

def load_vip_key(device_id):
    try:
        url_key = "https://raw.githubusercontent.com/Cuongdz2828/pt/main/test/a.txt"
        r = requests.get(url_key, timeout=8)
        r.raise_for_status()
        ds_key_raw = r.text.strip().splitlines()
        dev_local = device_id.replace("DEVICE-", "").strip().upper()
        for dong in ds_key_raw:
            parts = [p.strip() for p in dong.split("|")]
            if len(parts) >= 4:
                device, key, _, ngay_hh = parts[:4]
                dev_file = device.replace("DEVICE-", "").strip().upper()
                if dev_file == dev_local:
                    return key, ngay_hh
    except Exception:
        pass
    return None, None

def kiem_tra_quyen_truy_cap(device_id):
    global GLOBAL_KEY_MODE
    print(Fore.CYAN + "\n" + "=" * 48)
    print(Fore.YELLOW + "   CH·ªåN LO·∫†I KEY")
    print(Fore.CYAN + "=" * 48)
    print(Fore.GREEN + "1. Key Free (v∆∞·ª£t link)")
    print(Fore.MAGENTA + "2. Key VIP (ib C∆∞·ªùng ƒë·ªÉ mua)")
    print(Fore.CYAN + "=" * 48)
    choice = input(Fore.YELLOW + "Ch·ªçn (1-2): " + Fore.WHITE).strip()

    if choice == "1":
        GLOBAL_KEY_MODE = "FREE"
        print(Fore.CYAN + "\nB·∫°n ƒë√£ ch·ªçn Key Free")
        print(Fore.YELLOW + "üëâ Vui l√≤ng m·ªü link r√∫t g·ªçn 4m ƒë·ªÉ l·∫•y key:")

        free_links = [
            "https://link4m.com/Bhdv5",
            "https://link4m.com/LvWUEq5F",
            "https://link4m.com/Bhbv5",
            "https://link4m.com/LvWUEq5F",
        ]
        random_link = random.choice(free_links)
        print(Fore.GREEN + "   " + random_link)

        print(Fore.YELLOW + "Sau khi v∆∞·ª£t qua, ƒë·ªÉ th·∫•y User ID + Key Free")

        user_id = input(Fore.YELLOW + "üëâ Nh·∫≠p User ID (copy t·ª´ web): " + Fore.WHITE).strip()
        free_key = make_free_key(user_id)

        while True:
            key_nhap = input(Fore.YELLOW + "Nh·∫≠p Key Free: " + Fore.WHITE).strip()
            if key_nhap == free_key:
                h, m = thoi_gian_con_lai_trong_ngay()
                print(Fore.GREEN + f"‚úÖ D√πng Key Free th√†nh c√¥ng! C√≤n hi·ªáu l·ª±c {h}h {m}m\n")
                break
            else:
                print(Fore.RED + "‚ùå Key Free sai, th·ª≠ l·∫°i...")

    elif choice == "2":
        GLOBAL_KEY_MODE = "VIP"
        print(Fore.CYAN + "\nB·∫°n ƒë√£ ch·ªçn Key VIP")
        vip_key, ngay_hh = load_vip_key(device_id)
        if not vip_key:
            print(Fore.RED + "‚ùå Kh√¥ng t√¨m th·∫•y Key VIP ")
            raise SystemExit(1)
        print(Fore.YELLOW + f"‚≠ê Key VIP c·ªßa b·∫°n: {Fore.MAGENTA}{vip_key} (h·∫°n {ngay_hh})")
        while True:
            key_nhap = input(Fore.YELLOW + "Nh·∫≠p Key VIP: " + Fore.WHITE).strip()
            if key_nhap == vip_key:
                try:
                    ngay_hh_dt = datetime.strptime(ngay_hh, "%d/%m/%Y").date()
                    today_local = (datetime.utcnow() + timedelta(hours=7)).date()
                    if today_local <= ngay_hh_dt:
                        print(Fore.GREEN + "‚úÖ Key VIP c√≤n hi·ªáu l·ª±c!\n")
                        break
                    else:
                        print(Fore.RED + "‚ùå Key VIP ƒë√£ h·∫øt h·∫°n!")
                except Exception:
                    print(Fore.RED + "‚ùå L·ªói ƒë·ªãnh d·∫°ng ng√†y trong VIP key!")
            else:
                print(Fore.RED + "‚ùå Key VIP sai, th·ª≠ l·∫°i...")
    else:
        print(Fore.RED + "‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!")
        raise SystemExit(1)

def fetch_data(url, headers):
    headers["User-Agent"] = random.choice(USER_AGENTS)  # Th√™m User-Agent ng·∫´u nhi√™n
    try:
        r = requests.get(url, headers=headers, timeout=15)
        if r.status_code == 200:
            return r.json()
        else:
            print(Fore.RED + f"‚ö†Ô∏è API tr·∫£ v·ªÅ m√£ {r.status_code}: {r.text}")
    except Exception as e:
        print(Fore.RED + f"‚ö†Ô∏è L·ªói fetch_data: {e}")
    return None

def analyze_data(headers, asset_mode="BUILD"):
    url_recent_10 = f"https://api.sprintrun.win/sprint/recent_10_issues?asset={asset_mode}"
    url_recent_100 = f"https://api.sprintrun.win/sprint/recent_100_issues?asset={asset_mode}"
    data_10 = fetch_data(url_recent_10, headers)
    data_100 = fetch_data(url_recent_100, headers)

    if not data_10 or not data_100:
        return None, [], None, None, {}, [], {}

    issues_10 = []
    if isinstance(data_10, dict):
        if "data" in data_10 and isinstance(data_10["data"], dict):
            issues_10 = (
                data_10["data"].get("recent_10")
                or data_10["data"].get("issues")
                or data_10["data"].get("list")
                or []
            )
        else:
            issues_10 = (
                data_10.get("data")
                or data_10.get("issues")
                or []
            )
    elif isinstance(data_10, list):
        issues_10 = data_10

    if not isinstance(issues_10, list) or not issues_10:
        print(Fore.RED + "‚ùå API kh√¥ng tr·∫£ v·ªÅ d·ªØ li·ªáu 10 v√°n ho·∫∑c d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.")
        return None, [], None, None, {}, [], {}

    first_issue = issues_10[0]
    current_issue = first_issue.get("issue_id")
    champion_id = None
    if isinstance(first_issue.get("result"), list) and first_issue["result"]:
        champion_id = first_issue["result"][0]
    killed_room_id = str(champion_id) if champion_id is not None else None
    killed_room_name = room_names_map.get(killed_room_id, f"Ph√≤ng #{killed_room_id}") if killed_room_id else "N/A"

    stats_100 = {}
    if isinstance(data_100, dict):
        if "data" in data_100 and isinstance(data_100["data"], dict):
            stats_100 = (
                data_100["data"].get("athlete_2_win_times")
                or data_100["data"].get("room_id_2_killed_times")
                or data_100["data"].get("stats")
                or {}
            )
        else:
            stats_100 = (
                data_100.get("athlete_2_win_times")
                or data_100.get("room_id_2_killed_times")
                or data_100.get("stats")
                or {}
            )
        if not isinstance(stats_100, dict):
            stats_100 = {}

    rates_100 = {}
    for rid in room_names_map.keys():
        try:
            rates_100[rid] = int(stats_100.get(str(rid), 0))
        except Exception:
            rates_100[rid] = 0

    sorted_rooms_win = sorted(rates_100.items(), key=lambda x: x[1], reverse=True)
    sorted_rooms_not_win = sorted(rates_100.items(), key=lambda x: x[1])

    return current_issue, [sorted_rooms_win, sorted_rooms_not_win], killed_room_id, killed_room_name, rates_100, issues_10, stats_100

def place_bet(headers, bet_group, asset_type, athlete_id, issue_id, bet_amount=1.0):
    headers["User-Agent"] = random.choice(USER_AGENTS)  # Th√™m User-Agent ng·∫´u nhi√™n
    url = "https://api.sprintrun.win/sprint/bet"
    payload = {
        "issue_id": str(issue_id),
        "bet_group": bet_group,
        "asset_type": asset_type,
        "athlete_id": int(athlete_id),
        "bet_amount": float(bet_amount)
    }
    try:
        r = requests.post(url, headers=headers, json=payload, timeout=10)
        data = r.json()
        if data.get("code") in (0, 200):
            # Thay ƒë·ªïi ·ªü ƒë√¢y: S·ª≠ d·ª•ng t√™n t·ª´ room_names_map thay v√¨ athlete_id
            athlete_name = room_names_map.get(str(athlete_id), f"Ph√≤ng #{athlete_id}")
            print(Fore.GREEN + f"‚úÖ ƒê·∫∑t c∆∞·ª£c th√†nh c√¥ng: {bet_amount} {asset_type} -> {athlete_name}")
            return True
        else:
            print(Fore.RED + f"‚ùå ƒê·∫∑t c∆∞·ª£c th·∫•t b·∫°i: {data}")
    except Exception as e:
        print(Fore.RED + f"‚ùå L·ªói ƒë·∫∑t c∆∞·ª£c: {e}")
    return False

def manual_place_bet(headers, issue_id, champion_id, user_data, asset_mode="BUILD"):
    headers["User-Agent"] = random.choice(USER_AGENTS)  # Th√™m User-Agent ng·∫´u nhi√™n
    url = "https://api.sprintrun.win/sprint/bet"
    bet_mode = "champion" if user_data.get("choice_bet") == "winner" else "not_champion"
    bet_group = "winner" if bet_mode == "champion" else "not_winner"

    payload = {
        "coin": asset_mode,
        "issue_id": str(issue_id),
        "champion_id": int(champion_id),
        "bet_amount": float(user_data.get("coins", 1)),
        "bet_mode": bet_mode,
        "bet_group": bet_group
    }

    try:
        r = requests.post(url, headers=headers, json=payload, timeout=10)
        if r.status_code == 200:
            data = r.json()
            if data.get("code") == 0:
                print(Fore.GREEN + f"‚úÖ ƒê·∫∑t c∆∞·ª£c tay th√†nh c√¥ng k·ª≥ {issue_id}")
                return True
            else:
                print(Fore.RED + f"‚ùå ƒê·∫∑t c∆∞·ª£c tay th·∫•t b·∫°i: {data}")
        else:
            print(Fore.RED + f"‚ùå HTTP {r.status_code}: {r.text}")
    except Exception as e:
        print(Fore.RED + f"‚ùå L·ªói ƒë·∫∑t c∆∞·ª£c tay: {e}")
    return False

def show_wallet(headers, retries=3, delay=2, silent=False):
    headers["User-Agent"] = random.choice(USER_AGENTS)  # Th√™m User-Agent ng·∫´u nhi√™n
    url = "https://wallet.3games.io/api/wallet/user_asset"
    balances = {"USDT": 0.0, "WORLD": 0.0, "BUILD": 0.0}
    payload = {"user_id": headers.get("User-Id")}
    for attempt in range(retries):
        try:
            r = requests.post(url, headers=headers, json=payload, timeout=10)
            if r.status_code == 200:
                vi_data = r.json()
                if isinstance(vi_data, dict) and vi_data.get("code") == 0:
                    data = vi_data.get("data", {})
                    if isinstance(data, dict) and "user_asset" in data:
                        ua = data["user_asset"] or {}
                        for k in balances.keys():
                            v = ua.get(k)
                            try:
                                value = float(v) if v is not None else 0.0
                            except Exception:
                                value = 0.0
                            balances[k] = round(value, 2) if value >= 0.01 else 0.0
                    if not silent:
                        print(
                            Fore.LIGHTGREEN_EX
                            + f"S·ªë d∆∞ c·ªßa b·∫°n:\nUSDT: {balances['USDT']}   WORLD: {balances['WORLD']}   BUILD: {balances['BUILD']}"
                        )
                    return balances["BUILD"]
        except Exception:
            pass
        if attempt < retries - 1:
            time.sleep(delay)
    return balances["BUILD"]

def save_link(link):
    try:
        with open("links.txt", "w", encoding="utf-8") as f:
            f.write(link.strip())
    except Exception:
        pass

def load_link():
    try:
        if os.path.exists("links.txt"):
            with open("links.txt", "r", encoding="utf-8") as f:
                return f.read().strip()
    except Exception:
        pass
    return None

def print_game_data(issues_10, stats_100, bot_choice_name, last_champion_name):
    print(Fore.CYAN + "\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" + Fore.WHITE)
    print(Fore.CYAN + "‚ïë" + Fore.YELLOW + " D·ªÆ LI·ªÜU 10 V√ÅN     " + Fore.CYAN + "‚ïë" + Fore.WHITE)
    print(Fore.CYAN + "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" + Fore.WHITE)
    for issue in issues_10:
        issue_id = issue.get("issue_id", "N/A")
        champion_id = None
        if isinstance(issue.get("result"), list) and issue["result"]:
            champion_id = issue["result"][0]
        champion_name = room_names_map.get(str(champion_id), f"Ph√≤ng #{champion_id}")
        print(Fore.CYAN + f"K√¨ {issue_id}: Ng∆∞·ªùi v·ªÅ nh·∫•t : {champion_name}")

    print(Fore.CYAN + "\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" + Fore.WHITE)
    print(Fore.CYAN + "‚ïë" + Fore.YELLOW + " D·ªÆ LI·ªÜU 100 V√ÅN " + Fore.CYAN + "‚ïë" + Fore.WHITE)
    print(Fore.CYAN + "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" + Fore.WHITE)
    for rid, name in room_names_map.items():
        try:
            count = int(stats_100.get(str(rid), 0))
        except Exception:
            count = 0
        print(Fore.YELLOW + f"{name} v·ªÅ nh·∫•t {count} l·∫ßn")
    
    print(Fore.CYAN + "\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" + Fore.WHITE)
    print(Fore.CYAN + "‚ïë" + Fore.YELLOW + " BOT CH·ªåN " + Fore.CYAN + "‚ïë" + Fore.WHITE)
    print(Fore.CYAN + "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" + Fore.WHITE)
    print(Fore.BLUE + f"BOT CH·ªåN : {bot_choice_name or 'N/A'}")
    print(Fore.GREEN + f"Qu√°n qu√¢n k·ª≥ tr∆∞·ªõc : {last_champion_name}")

def calc_next_issue_id(current_issue):
    s = str(current_issue)
    tail = s.split("-")[-1]
    try:
        n = int(tail)
        return str(n + 1)
    except Exception:
        try:
            return str(int(s) + 1)
        except Exception:
            return s

if __name__ == "__main__":
    # Hi·ªÉn th·ªã hi·ªáu ·ª©ng ASCII art khi kh·ªüi ƒë·ªông
    display_ascii_art()

    device_id = get_device_id()
    kiem_tra_quyen_truy_cap(device_id)

    print(Fore.CYAN + "\n================= LI√äN H·ªÜ ADMIN ================")
    print(Fore.YELLOW + "üë®‚Äçüíª Admin: " + Fore.GREEN + "C∆∞·ªùng")
    print(Fore.YELLOW + "üí¨ Zalo Group: " + Fore.CYAN + "https://zalo.me/g/cdomty095")
    print(Fore.CYAN + "================================================\n")

    print(Fore.YELLOW + "\n================ H∆Ø·ªöNG D·∫™N L·∫§Y LINK ============\n")
    print(Fore.CYAN + "0. M·ªü Chrome")
    print(Fore.CYAN + "1. ƒêƒÉng nh·∫≠p xworld.io ‚Üí m·ªü game SprintRun")
    print(Fore.CYAN + "2. Sao ch√©p link c√≥ d·∫°ng ?userId=...&secretKey=...&language=vi-VN")
    print(Fore.CYAN + "3. D√°n link v√†o ƒë√¢y\n")

    saved_link = load_link()
    if saved_link:
        use_saved = input(Fore.YELLOW + "S·ª≠ d·ª•ng l·∫°i link ƒë√£ l∆∞u? (y/n): ").strip().lower()
        if use_saved == "y":
            link = saved_link
            print(Fore.GREEN + f"‚úÖ S·ª≠ d·ª•ng link ƒë√£ l∆∞u: {link}")
        else:
            link = input("D√°n link game m·ªõi: ").strip()
            save_link(link)
    else:
        link = input("D√°n link game: ").strip()
        save_link(link)

    parsed = urlparse(link)
    params = parse_qs(parsed.query)
    user_id = params.get("userId", [""])[0]
    secret_key = params.get("secretKey", [""])[0]
    lang = params.get("language", ["vi-VN"])[0]

    if not user_id or not secret_key:
        print(Fore.RED + "‚ùå Link kh√¥ng h·ª£p l·ªá (thi·∫øu userId/secretKey).")
        raise SystemExit(1)

    headers = {
        "User-Id": user_id,
        "User-Secret-Key": secret_key,
        "Accept-Language": lang,
        "Content-Type": "application/json",
    }

    print(Fore.CYAN + "‚ïê" * 40)
    print(Fore.YELLOW + "   CH·ªåN KI·ªÇU C∆Ø·ª¢C")
    print(Fore.CYAN + "‚ïê" * 40)
    print(Fore.GREEN + "1. C∆∞·ª£c Qu√°n qu√¢n")
    print(Fore.MAGENTA + "2. C∆∞·ª£c Kh√¥ng qu√°n qu√¢n")
    bet_mode_choice = input(Fore.RED + "Ch·ªçn (1-2): " + Fore.WHITE).strip()
    bet_mode = "champion" if bet_mode_choice == "1" else "not_champion"

    try:
        bet_amount = float(input(Fore.YELLOW + "Nh·∫≠p s·ªë BUILD c∆∞·ª£c ban ƒë·∫ßu: ").strip())
        amount_to_increase_on_loss = float(input(Fore.YELLOW + "TƒÉng c∆∞·ª£c sau m·ªói l·∫ßn thua: ").strip())
        win_limit = int(input(Fore.YELLOW + "Th·∫Øng m·∫•y v√°n th√¨ ngh·ªâ: ").strip())
        rest_games = int(input(Fore.YELLOW + "Ngh·ªâ bao nhi√™u v√°n: ").strip())
        win_stop = float(input(Fore.YELLOW + "Th·∫Øng t·ªïng c·ªông bao nhi√™u BUILD th√¨ d·ª´ng (0=b·ªè qua): ").strip())
        loss_stop = float(input(Fore.YELLOW + "Thua bao nhi√™u BUILD th√¨ d·ª´ng (0=b·ªè qua): ").strip())
    except ValueError:
        bet_amount = 30.0
        amount_to_increase_on_loss = 10.0
        win_limit = 0
        rest_games = 0
        win_stop = 0.0
        loss_stop = 0.0
        print(Fore.YELLOW + "Nh·∫≠p sai. D√πng gi√° tr·ªã m·∫∑c ƒë·ªãnh.")

    current_bet_amount = bet_amount
    total_wins, total_losses = 0, 0
    win_streak = 0
    total_profit = 0.0
    pending_issue, pending_target = None, None
    room_picked_count = {}
    locked_rooms = {}
    pick_pattern = [1, 2, 1, 3, 1]
    pick_index = 0
    skip_rounds = 0

    initial_balance = show_wallet(headers)
    print(Fore.YELLOW + f"S·ªë d∆∞ ban ƒë·∫ßu (BUILD): {initial_balance}")

    last_processed_issue = None

    while True:
        if GLOBAL_KEY_MODE == "FREE":
            h, m = thoi_gian_con_lai_trong_ngay()
            print(Fore.GREEN + f"\nKey FREE VTH c√≤n hi·ªáu l·ª±c ({h}h {m}m)")

        current_balance = show_wallet(headers, silent=True)
        current_issue, rankings, last_champion_id, last_champion_name, w100, issues_10, stats_100 = analyze_data(headers)

        if not current_issue:
            print(Fore.RED + "API thi·∫øu issue hi·ªán t·∫°i, th·ª≠ l·∫°i...")
            time.sleep(3)
            continue

        champion_sorted, not_champion_sorted = rankings

        if last_processed_issue and str(last_processed_issue) != str(current_issue):
            time.sleep(3)
            new_balance = show_wallet(headers)
            profit = (new_balance - current_balance) if (new_balance is not None and current_balance is not None) else 0.0
            total_profit = new_balance - initial_balance if new_balance is not None else total_profit

            if bet_mode == "champion":
                is_win = (str(pending_target) == str(last_champion_id))
            else:
                is_win = (str(pending_target) != str(last_champion_id))

            if is_win:
                total_wins += 1
                win_streak += 1
                print(Fore.GREEN + f"üéâ K·ª≥ {last_processed_issue}: TH·∫ÆNG (+{profit:.2f} BUILD)")
                current_bet_amount = bet_amount
                if win_limit > 0 and (total_wins % win_limit == 0):
                    print(Fore.CYAN + f"üõë ƒê√£ th·∫Øng {total_wins} v√°n, t·∫°m ngh·ªâ {rest_games} v√°n...")
                    skip_rounds = rest_games
            else:
                total_losses += 1
                win_streak = 0
                print(Fore.RED + f"üíÄ K·ª≥ {last_processed_issue}: THUA ({profit:.2f} BUILD)")
                current_bet_amount = max(bet_amount, current_bet_amount + amount_to_increase_on_loss)

            if win_stop > 0 and total_profit >= win_stop:
                print(Fore.CYAN + f"üèÜ ƒê√£ l·ªùi {total_profit:.2f} BUILD (>= {win_stop}), t·ª± ƒë·ªông tho√°t.")
                raise SystemExit(0)

            if loss_stop > 0 and total_profit <= -loss_stop:
                print(Fore.RED + f"üíÄ ƒê√£ l·ªó {abs(total_profit):.2f} BUILD (>= {loss_stop}), t·ª± ƒë·ªông tho√°t.")
                raise SystemExit(0)

            target_name = room_names_map.get(str(pending_target), f"Qu√°n qu√¢n #{pending_target}")
            print(Fore.YELLOW + f"üéØ B·∫°n ch·ªçn: {target_name}")
            print(Fore.CYAN + f"üëë Qu√°n qu√¢n: {last_champion_name}")
            pending_issue, pending_target = None, None
            time.sleep(2)

        if not pending_issue:
            if skip_rounds > 0:
                print(Fore.MAGENTA + f"‚è∏Ô∏è ƒêang ngh·ªâ, c√≤n {skip_rounds} v√°n...")
                skip_rounds -= 1
                last_processed_issue = current_issue
                time.sleep(4)
                continue

        for rid in list(locked_rooms.keys()):
            locked_rooms[rid] = max(0, locked_rooms[rid] - 1)
            if locked_rooms[rid] <= 0:
                locked_rooms.pop(rid, None)

        ranking = champion_sorted if bet_mode == "champion" else not_champion_sorted
        if not ranking:
            print(Fore.RED + "‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu x·∫øp h·∫°ng. B·ªè qua k·ª≥ n√†y.")
            last_processed_issue = current_issue
            time.sleep(2)
            continue

        target_rank = pick_pattern[pick_index]
        pick_index = (pick_index + 1) % len(pick_pattern)

        available = [(rid, val) for rid, val in ranking if locked_rooms.get(str(rid), 0) == 0]
        if not available:
            print(Fore.RED + "‚ö†Ô∏è T·∫•t c·∫£ l·ª±a ch·ªçn ƒëang b·ªã kh√≥a, b·ªè qua k·ª≥ n√†y.")
            last_processed_issue = current_issue
            time.sleep(2)
            continue

        if len(available) >= target_rank:
            best_id, _best_val = available[target_rank - 1]
        else:
            best_id, _best_val = available[0]

        best_name = room_names_map.get(str(best_id), f"Qu√°n qu√¢n #{best_id}")
        room_picked_count[best_id] = room_picked_count.get(best_id, 0) + 1
        if room_picked_count[best_id] >= 2:
            locked_rooms[str(best_id)] = 1
            room_picked_count[best_id] = 0

        print_game_data(issues_10, stats_100, best_name, last_champion_name)

        print(Fore.RED + "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" + Fore.WHITE)
        print(Fore.YELLOW + "‚ïë" + Fore.YELLOW + " TH·ªêNG K√ä K·∫æT QU·∫¢ " + "‚ïë" + Fore.YELLOW)
        print(Fore.RED + "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" + Fore.WHITE)
        print(Fore.YELLOW + f"üìä Th·∫Øng/Thua: {total_wins}/{total_losses}")
        print(Fore.YELLOW + f"   T·ªïng tr·∫≠n: {total_wins + total_losses}")
        print(Fore.YELLOW + f"   Chu·ªói th·∫Øng: {win_streak}")
        print(Fore.YELLOW + f"   L·ªùi/L·ªó: {total_profit:.2f} BUILD\n")

        print(Fore.YELLOW + "‚è≥ Ch·ªù ƒë·ªÉ l·∫•y k·ª≥ m·ªõi...")
        time.sleep(10)

        try:
            next_issue = str(int(current_issue) + 1)
            print(
                Fore.CYAN
                + f"üí∞ C∆∞·ª£c k·ª≥ {next_issue}: {current_bet_amount} BUILD "
                + (f"({'Qu√°n qu√¢n' if bet_mode=='champion' else 'Kh√¥ng qu√°n qu√¢n'})")
            )

            bet_group = "winner" if bet_mode == "champion" else "not_winner"
            success = place_bet(headers, bet_group, "BUILD", int(best_id), next_issue, current_bet_amount)
            if success:
                pending_issue, pending_target = next_issue, str(best_id)
            else:
                print(Fore.RED + "‚ö†Ô∏è Kh√¥ng c√≥ qu√°n qu√¢n ƒë·ªÉ c∆∞·ª£c, b·ªè qua k·ª≥ n√†y.")
        except Exception as e:
            print(Fore.RED + f"‚ùå L·ªói x√°c ƒë·ªãnh k·ª≥ ti·∫øp theo: {e}")
            success = False

        last_processed_issue = current_issue
        print(Fore.RED + f"üëë Qu√°n qu√¢n k·ª≥ {current_issue}: {last_champion_name}\n")

        countdown = 1
        while True:
            time.sleep(1)
            print(Fore.YELLOW + f"ƒëang ph√¢n t√≠ch...{countdown}s", end="\r")
            countdown += 1
            new_issue, *_rest = analyze_data(headers)
            if new_issue and new_issue != current_issue:
                print(Fore.GREEN + "\nüéâ C√≥ k·ª≥ m·ªõi! ƒêang x·ª≠ l√Ω...")
                break
