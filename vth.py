import requests
import time
import os
import uuid
import random
import hashlib
import subprocess
import platform
from datetime import datetime, timezone, timedelta
from urllib.parse import urlparse, parse_qs
from colorama import Fore, init

init(autoreset=True)

room_names_map = {
    "1": "Nh√† Kho",
    "2": "Ph√≤ng H·ªçp",
    "3": "Ph√≤ng Gi√°m ƒê·ªëc",
    "4": "Ph√≤ng Tr√≤ Chuy·ªán",
    "5": "Ph√≤ng Gi√°m S√°t",
    "6": "VƒÉn Ph√≤ng",
    "7": "Ph√≤ng T√†i V·ª•",
    "8": "Ph√≤ng Nh√¢n S·ª±",
}

SECRET = "MY_SECRET_SALT"
GLOBAL_KEY_MODE = None


def get_device_id(mode="mac"):
    try:
        android_id = os.popen("settings get secure android_id").read().strip()
        model = os.popen("getprop ro.product.model").read().strip()
        brand = os.popen("getprop ro.product.brand").read().strip()
        serial = os.popen("getprop ro.serialno").read().strip()

        if android_id and model and brand:
            raw = f"{android_id}-{brand}-{model}-{serial}"
        else:
            raise Exception("Not Android")
    except:
        # PC th√¨ ch·ªçn mode
        if mode == "mac":
            raw = str(uuid.getnode())
        elif mode == "cpu":
            raw = f"{platform.processor()}-{platform.machine()}"
        elif mode == "disk":
            try:
                if platform.system() == "Windows":
                    disk_serial = subprocess.check_output(
                        "wmic diskdrive get SerialNumber", shell=True
                    ).decode(errors="ignore").split("\n")[1].strip()
                else:
                    disk_serial = subprocess.check_output(
                        "udevadm info --query=property --name=/dev/sda | grep ID_SERIAL",
                        shell=True
                    ).decode(errors="ignore").strip()
            except:
                disk_serial = "NOSERIAL"
            raw = disk_serial
        else:
            raw = f"{platform.node()}-{platform.system()}-{platform.release()}"

    device_id = "DEVICE-" + hashlib.md5(raw.encode()).hexdigest()[:15].upper()
    print(Fore.BLUE + "üìå Device ID:" +Fore.YELLOW + f" {device_id}")
    return device_id


def make_free_key(user_id):
    today = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    raw = today + SECRET + user_id
    return hashlib.md5(raw.encode()).hexdigest()[:10].upper()


def thoi_gian_con_lai_trong_ngay():
    now = datetime.utcnow() + timedelta(hours=7)
    tomorrow = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
    delta = tomorrow - now
    hours, remainder = divmod(delta.seconds, 3600)
    minutes = remainder // 60
    return hours, minutes


def load_vip_key(device_id):
    try:
        url_key = "https://raw.githubusercontent.com/Cuongdz2828/pt/main/test/a.txt"
        ds_key_raw = requests.get(url_key, timeout=5).text.strip().splitlines()
        dev_local = device_id.replace("DEVICE-", "").strip().upper()
        for dong in ds_key_raw:
            parts = [p.strip() for p in dong.split("|")]
            if len(parts) >= 4:
                device, key, _, ngay_hh = parts
                dev_file = device.replace("DEVICE-", "").strip().upper()
                if dev_file == dev_local:
                    return key, ngay_hh
    except:
        pass
    return None, None



def kiem_tra_quyen_truy_cap(device_id):
    global GLOBAL_KEY_MODE
    print(Fore.CYAN + "\n" + "=" * 48)
    print(Fore.YELLOW + "   CH·ªåN LO·∫†I KEY")
    print(Fore.CYAN + "=" * 48)
    print(Fore.GREEN + "1. Key Free (v∆∞·ª£t link)")
    print(Fore.MAGENTA + "2. Key VIP (ib C∆∞·ªùng ƒë·ªÉ mua)")
    print(Fore.CYAN + "=" * 48)

    choice = input(Fore.YELLOW + "Ch·ªçn (1-2): " + Fore.WHITE).strip()

    if choice == "1":
        GLOBAL_KEY_MODE = "FREE"
        print(Fore.CYAN + "\nB·∫°n ƒë√£ ch·ªçn Key Free")
        print(Fore.YELLOW + "üëâ Vui l√≤ng m·ªü link r√∫t g·ªçn 4m ƒë·ªÉ l·∫•y key:")

        free_links = [
            "https://link4m.com/Bhdv5",
            "https://link4m.com/LvWUEq5F",
            "https://link4m.com/Bhdv5",
            "https://link4m.com/LvWUEq5F",
        ]
        random_link = random.choice(free_links)
        print(Fore.GREEN + "   " + random_link)

        print(Fore.YELLOW + "Sau khi v∆∞·ª£t qua, ƒë·ªÉ th·∫•y User ID + Key Free")

        user_id = input(Fore.YELLOW + "üëâ Nh·∫≠p User ID (copy t·ª´ web): " + Fore.WHITE).strip()
        free_key = make_free_key(user_id)

        while True:
            key_nhap = input(Fore.YELLOW + "Nh·∫≠p Key Free: " + Fore.WHITE).strip()
            if key_nhap == free_key:
                h, m = thoi_gian_con_lai_trong_ngay()
                print(Fore.GREEN + f"‚úÖ D√πng Key Free th√†nh c√¥ng! C√≤n hi·ªáu l·ª±c {h}h {m}m\n")
                break
            else:
                print(Fore.RED + "‚ùå Key Free sai, th·ª≠ l·∫°i...")

    elif choice == "2":
        GLOBAL_KEY_MODE = "VIP"
        print(Fore.CYAN + "\nB·∫°n ƒë√£ ch·ªçn Key VIP")
        vip_key, ngay_hh = load_vip_key(device_id)

        if vip_key:
            print(Fore.YELLOW + f"‚≠ê Key VIP c·ªßa b·∫°n: {Fore.MAGENTA}{vip_key} (h·∫°n {ngay_hh})")
        else:
            print(Fore.RED + "‚ùå Kh√¥ng t√¨m th·∫•y Key VIP ")
            exit()

        while True:
            key_nhap = input(Fore.YELLOW + "Nh·∫≠p Key VIP: " + Fore.WHITE).strip()
            if key_nhap == vip_key:
                try:
                    ngay_hh_dt = datetime.strptime(ngay_hh, "%d/%m/%Y")
                    if datetime.now() <= ngay_hh_dt:
                        print(Fore.GREEN + "‚úÖ Key VIP c√≤n hi·ªáu l·ª±c!\n")
                        break
                    else:
                        print(Fore.RED + "‚ùå Key VIP ƒë√£ h·∫øt h·∫°n!")
                except:
                    print(Fore.RED + "‚ùå L·ªói ƒë·ªãnh d·∫°ng ng√†y trong VIP key!")
            else:
                print(Fore.RED + "‚ùå Key VIP sai, th·ª≠ l·∫°i...")
    else:
        print(Fore.RED + "‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!")
        exit()


def fetch_data(url, headers):
    try:
        r = requests.get(url, headers=headers, timeout=15)
        if r.status_code == 200:
            data = r.json()
            if data.get("code") == 0:
                return data["data"]
    except Exception:
        pass
    return None


def analyze_data(headers, asset_mode):
    url_recent_10 = f"https://api.escapemaster.net/escape_game/recent_10_issues?asset={asset_mode}"
    url_recent_100 = f"https://api.escapemaster.net/escape_game/recent_100_issues?asset={asset_mode}"
    data_10 = fetch_data(url_recent_10, headers)
    data_100 = fetch_data(url_recent_100, headers)

    if not data_10 or not data_100:
        return None, [], None, None, {}

    current_issue = data_10[0].get("issue_id")
    killed_room_id = str(data_10[0].get("killed_room_id", "0"))
    killed_room_name = room_names_map.get(killed_room_id, f"Ph√≤ng #{killed_room_id}")

    rates_100 = {}
    stats_100 = data_100.get("room_id_2_killed_times", {})
    for rid, name in room_names_map.items():
        count = stats_100.get(rid, 0)
        rates_100[rid] = 100 - (count / 100 * 100) if count > 0 else 100

    sorted_rooms = sorted(rates_100.items(), key=lambda x: x[1], reverse=True)
    return current_issue, sorted_rooms, killed_room_id, killed_room_name, rates_100


def place_bet(headers, asset, issue_id, room_id, bet_amount):
    url = "https://api.escapemaster.net/escape_game/bet"
    payload = {
        "asset_type": asset,
        "issue_id": str(issue_id),
        "room_id": int(room_id),
        "bet_amount": bet_amount,
    }
    try:
        r = requests.post(url, headers=headers, json=payload, timeout=10)
        data = r.json()
        if r.status_code == 200 and data.get("code") == 0:
            print(Fore.GREEN + f"‚úÖ ƒê·∫∑t c∆∞·ª£c th√†nh c√¥ng {bet_amount} {asset} v√†o ph√≤ng {room_id} (K·ª≥ {issue_id})")
            return True
    except Exception:
        pass
    return False


def show_wallet(headers, asset_mode, retries=3, delay=2, silent=False):
    url = "https://wallet.3games.io/api/wallet/user_asset"
    balances = {"USDT": 0.0, "WORLD": 0.0, "BUILD": 0.0}
    payload = {"user_id": headers.get("User-Id")}

    for attempt in range(retries):
        try:
            r = requests.post(url, headers=headers, json=payload, timeout=10)
            if r.status_code == 200:
                vi_data = r.json()
                if vi_data.get("code") == 0:
                    data = vi_data.get("data", {})
                    if isinstance(data, dict) and "user_asset" in data:
                        ua = data["user_asset"]
                        for k, v in ua.items():
                            if k in balances:
                                value = float(v) if v is not None else 0.0
                                balances[k] = round(value, 2) if value >= 0.01 else 0.0
                    if not silent:
                        print(
                            Fore.LIGHTGREEN_EX
                            + f"S·ªë d∆∞ ({asset_mode}): {balances[asset_mode]}\n"
                        )
                    return balances[asset_mode]
        except Exception:
            pass
        if attempt < retries - 1:
            time.sleep(delay)
    return balances[asset_mode]


def save_link(link):
    with open("link.txt", "w") as f:
        f.write(link)


def load_link():
    if os.path.exists("link.txt"):
        with open("link.txt", "r") as f:
            return f.read().strip()
    return None


if __name__ == "__main__":
    device_id = get_device_id()
    kiem_tra_quyen_truy_cap(device_id)

    print(Fore.CYAN + "\n================= LI√äN H·ªÜ ADMIN ================")
    print(Fore.YELLOW + "üë®‚Äçüíª Admin: " + Fore.GREEN + "C∆∞·ªùng")
    print(Fore.YELLOW + "üí¨ Zalo Group: " + Fore.CYAN + "https://zalo.me/g/cdomty095")
    print(Fore.CYAN + "key vip 1k/2 ng√†y")"================================================\n")

    print(Fore.YELLOW + "\n================ H∆Ø·ªöNG D·∫™N L·∫§Y LINK ============\n")
    print(Fore.CYAN + "0. M·ªü Chrome")
    print(Fore.CYAN + "1. Truy c·∫≠p website: " + Fore.GREEN + "xworld.io")
    print(Fore.CYAN + "2. ƒêƒÉng nh·∫≠p v√†o t√†i kho·∫£n")
    print(Fore.CYAN + "3. T√¨m v√† nh·∫•p v√†o: " + Fore.GREEN + "Vua tho√°t hi·ªÉm")
    print(Fore.CYAN + "4. Nh·∫•n l·∫≠p t·ª©c truy c·∫≠p")
    print(Fore.CYAN + "5. Sao ch√©p link website v√† d√°n v√†o ƒë√¢y\n")

    saved_link = load_link()
    if saved_link:
        use_saved = input(Fore.YELLOW + "S·ª≠ d·ª•ng l·∫°i link ƒë√£ l∆∞u? (y/n): ").strip().lower()
        if use_saved == "y":
            link = saved_link
            print(Fore.GREEN + f"‚úÖ S·ª≠ d·ª•ng link ƒë√£ l∆∞u: {link}")
        else:
            link = input("D√°n link game m·ªõi: ").strip()
            save_link(link)
    else:
        link = input("D√°n link game: ").strip()
        save_link(link)

    parsed = urlparse(link)
    params = parse_qs(parsed.query)
    user_id = params.get("userId", [""])[0]
    secret_key = params.get("secretKey", [""])[0]
    headers = {
        "User-Id": user_id,
        "User-Secret-Key": secret_key,
        "Content-Type": "application/json",
    }

    print(Fore.CYAN + "‚ïê" * 48)
    print(Fore.YELLOW + "   CH·ªåN CH·∫æ ƒê·ªò")
    print(Fore.CYAN + "‚ïê" * 48)
    print(Fore.GREEN + "1. BUILD")
    print(Fore.MAGENTA + "2. USDT")
    print(Fore.LIGHTYELLOW_EX + "3. WORLD")
    choice = input(Fore.GREEN + "Ch·ªçn (1-3): ")
    asset_mode = {"1": "BUILD", "2": "USDT", "3": "WORLD"}.get(choice, "BUILD")

    try:
        bet_amount = float(input(Fore.YELLOW + "Nh·∫≠p s·ªë ti·ªÅn c∆∞·ª£c ban ƒë·∫ßu m·ªói tr·∫≠n: ").strip())
        amount_to_increase_on_loss = float(input(Fore.YELLOW + "Nh·∫≠p s·ªë ti·ªÅn mu·ªën tƒÉng c∆∞·ª£c sau m·ªói l·∫ßn thua: ").strip())
        win_limit = int(input(Fore.YELLOW + "Win m·∫•y v√°n th√¨ s·∫Ω d·ª´ng c∆∞·ª£c: ").strip())
        rest_games = int(input(Fore.YELLOW + "S·∫Ω d·ª´ng c∆∞·ª£c bao nhi√™u v√°n: ").strip())
        win_stop = float(input(Fore.YELLOW + "Th·∫Øng bao nhi√™u BUILD th√¨ d·ª´ng: ").strip())
        loss_stop = float(input(Fore.YELLOW + "Thua bao nhi√™u BUILD th√¨ d·ª´ng: ").strip())
    except ValueError:
        bet_amount = 10.0
        amount_to_increase_on_loss = 10.0
        win_limit = 0
        rest_games = 0
        win_stop = 0.0
        loss_stop = 0.0
        print(Fore.YELLOW + "Nh·∫≠p sai. D√πng gi√° tr·ªã m·∫∑c ƒë·ªãnh.")

    current_bet_amount = bet_amount
    total_wins, total_losses = 0, 0
    win_streak = 0
    pending_issue, pending_room = None, None
    total_profit = 0.0

    room_picked_count = {}
    locked_rooms = {}
    pick_pattern = [1, 1, 2, 1, 2]

    pick_index = 0
    skip_rounds = 0

    initial_balance = show_wallet(headers, asset_mode)
    print(Fore.YELLOW + f"S·ªë d∆∞ ban ƒë·∫ßu ({asset_mode}): {initial_balance}")

    while True:
        if GLOBAL_KEY_MODE == "FREE":
            h, m = thoi_gian_con_lai_trong_ngay()
            print(Fore.GREEN + f"\nKey FREE VTH c√≤n hi·ªáu l·ª±c ({h}h {m}m)")

        current_balance = show_wallet(headers, asset_mode, silent=True)
        current_issue, sorted_rooms, killed_room_id, killed_room_name, rates_100 = analyze_data(headers, asset_mode)

        if not current_issue:
            print(Fore.RED + "Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu API...")
            time.sleep(5)
            continue

        if pending_issue and str(pending_issue) == str(current_issue):
            time.sleep(3)
            new_balance = show_wallet(headers, asset_mode)
            profit = new_balance - current_balance
            total_profit = new_balance - initial_balance
            
            if killed_room_id != pending_room:
                total_wins += 1
                win_streak += 1
                print(Fore.GREEN + f"üéâ K·ª≥ {current_issue}: TH·∫ÆNG (+{profit:.2f} {asset_mode})")
                current_bet_amount = bet_amount
                if win_limit > 0 and total_wins % win_limit == 0:
                    print(Fore.CYAN + f"üõë ƒê√£ th·∫Øng {total_wins} v√°n, t·∫°m ngh·ªâ {rest_games} v√°n...")
                    skip_rounds = rest_games
            else:
                total_losses += 1
                win_streak = 0
                print(Fore.RED + f"üíÄ K·ª≥ {current_issue}: THUA ({profit:.2f} {asset_mode})")
                current_bet_amount += amount_to_increase_on_loss
            
            if win_stop > 0 and total_profit >= win_stop:
                print(Fore.CYAN + f"üèÜ ƒê√£ l·ªùi {total_profit:.2f} {asset_mode} (>= {win_stop}), t·ª± ƒë·ªông d·ª´ng!")
                exit()
            
            if loss_stop > 0 and total_profit <= -loss_stop:
                print(Fore.RED + f"üíÄ ƒê√£ l·ªó {abs(total_profit):.2f} {asset_mode} (>= {loss_stop}), t·ª± ƒë·ªông tho√°t.")
                exit()
            
            print(f"  AI ch·ªçn: {room_names_map.get(pending_room, f'Ph√≤ng #{pending_room}')}")
            print(Fore.RED + f"  S√°t th·ªß: {killed_room_name}")
            
            pending_issue, pending_room = None, None
            time.sleep(2)

        pred_id = str(int(current_issue) + 1)
        
        if skip_rounds > 0:
            print(Fore.MAGENTA + f"‚è∏Ô∏è ƒêang ngh·ªâ, c√≤n {skip_rounds} v√°n...")
            print(Fore.RED + f"üî™ S√°t th·ªß k·ª≥ {current_issue}: {killed_room_name}\n")
            skip_rounds -= 1
            
            countdown = 1
            while True:
                time.sleep(1)
                print(Fore.YELLOW + f"ƒëang ph√¢n t√≠ch...{countdown}s", end="\r")
                countdown += 1
                new_issue, _, _, _, _ = analyze_data(headers, asset_mode)
                if new_issue and new_issue != current_issue:
                    print(Fore.GREEN + "\nüéâ C√≥ k·ª≥ m·ªõi! ƒêang x·ª≠ l√Ω...")
                    break
            continue

        print(Fore.BLUE + "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" + Fore.WHITE)
        print(Fore.BLUE + "‚ïë" + Fore.YELLOW + " ƒê·∫∂T C∆Ø·ª¢C CHO K·ª≤ TI·∫æP THEO " + Fore.BLUE + "‚ïë" + Fore.WHITE)
        print(Fore.BLUE + "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" + Fore.WHITE)
        
        
        for rid in list(locked_rooms.keys()):
            if locked_rooms[rid] > 0:
                locked_rooms[rid] -= 1
            if locked_rooms[rid] <= 0:
                locked_rooms.pop(rid, None)

        if sorted_rooms:
            target_rank = pick_pattern[pick_index]
            pick_index = (pick_index + 1) % len(pick_pattern)

            available_rooms = [(rid, rate) for rid, rate in sorted_rooms
                               if locked_rooms.get(str(rid), 0) == 0 and str(rid) != str(killed_room_id)]
            
            if not available_rooms:
                print(Fore.RED + "‚ö†Ô∏è T·∫•t c·∫£ ph√≤ng ƒë·ªÅu b·ªã kh√≥a ho·∫∑c v·ª´a c√≥ s√°t th·ªß, b·ªè qua k·ª≥ n√†y.")
                time.sleep(2)
                continue
                
            if len(available_rooms) >= target_rank:
                best_room_id, best_rate = available_rooms[target_rank - 1]
            else:
                best_room_id, best_rate = available_rooms[0]
            
            best_room_name = room_names_map.get(str(best_room_id), f"Ph√≤ng #{best_room_id}")
            print(Fore.CYAN + f"üîÑ ch·ªçn ph√≤ng: ch·ªçn ph√≤ng {target_rank} ({best_room_name})")
            
            room_picked_count[best_room_id] = room_picked_count.get(best_room_id, 0) + 1
            if room_picked_count[best_room_id] >= 2:
                locked_rooms[best_room_id] = 1
                room_picked_count[best_room_id] = 0

            print(Fore.MAGENTA + f"‚úÖ Ph√≤ng ƒë∆∞·ª£c ch·ªçn: {best_room_name}")
            print(Fore.GREEN + f"üé≤ ƒë·ªô an to√†n: {best_rate:.1f}%")

            print(Fore.YELLOW + "üìà Top 3 ph√≤ng an to√†n:")
            for i in range(min(3, len(sorted_rooms))):
                room_id, rate = sorted_rooms[i]
                room_name = room_names_map.get(str(room_id), f"Ph√≤ng #{room_id}")
                print(Fore.YELLOW + f"   {i+1}. {room_name}: {rate:.1f}%")

            print(Fore.RED + "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" + Fore.WHITE)
            print(Fore.RED + "‚ïë" + Fore.YELLOW + " TH·ªêNG K√ä K·∫æT QU·∫¢ " + Fore.RED +"‚ïë" + Fore.WHITE)
            print(Fore.RED + "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" + Fore.WHITE)
            
            print(Fore.YELLOW + f"üìä T·ªâ l·ªá th·∫Øng/thua: {total_wins}/{total_losses}")
            print(Fore.YELLOW + f"   T·ªïng tr·∫≠n: {total_wins + total_losses}")
            print(Fore.YELLOW + f"   Chu·ªói th·∫Øng: {win_streak}")
            print(Fore.YELLOW + f"   L·ªùi/L·ªó: {total_profit:.2f} {asset_mode}\n")

            print(Fore.CYAN + f"üí∞ S·ªë ti·ªÅn c∆∞·ª£c cho k·ª≥ {pred_id}: {current_bet_amount} {asset_mode}")
            success = place_bet(headers, asset_mode, pred_id, int(best_room_id), current_bet_amount)
            if success:
                pending_issue, pending_room = pred_id, str(best_room_id)

        print(Fore.RED + f"üî™ S√°t th·ªß k·ª≥ {current_issue}: {killed_room_name}\n")

        countdown = 1
        while True:
            time.sleep(1)
            print(Fore.YELLOW + f"ƒëang ph√¢n t√≠ch...{countdown}s", end="\r")
            countdown += 1
            new_issue, _, _, _, _ = analyze_data(headers, asset_mode)
            if new_issue and new_issue != current_issue:
                print(Fore.GREEN + "\nüéâ C√≥ k·ª≥ m·ªõi! ƒêang x·ª≠ l√Ω...")
                break